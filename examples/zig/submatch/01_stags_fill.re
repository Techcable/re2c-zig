// re2rust $INPUT -o $OUTPUT
const std = @import("std");

const BUFSIZE: usize = 4096;
const NONE: usize = std.math.maxInt(usize);

const State = struct {
    alloc: std.mem.Allocator,
    file: *std.fs.File,
    buf: [BUFSIZE]u8,
    lim: usize,
    cur: usize,
    mar: usize,
    tok: usize,
    // Tag variables must be part of the lexer state passed to YYFILL.
    // They don't correspond to tags and should be autogenerated by re2c.
    /*!stags:re2c format = "@@: usize,\n"; */
    eof: bool,
};

const Fill = enum { Ok, Eof, LongLexeme };

const SemVer = struct {
    major: u32,
    minor: u32,
    patch: u32,

    pub fn format(
        self: SemVer,
        comptime fmt: []const u8,
        options: std.fmt.FormatOptions,
        out_stream: anytype,
    ) !void {
        _ = options;
        if (fmt.len != 0) std.fmt.invalidFmtError(fmt, self);
        try std.fmt.format(out_stream, "{d}.{d}.{d}", .{ self.major, self.minor, self.patch });
    }
};

fn s2n(str: []const u8) u32 { // convert a pre-parsed string to a number
    var n: u32 = 0;
    for (str) |i| { n = n * 10 + @as(u32, i) - 48; }
    return n;
}

fn shift(x: anytype, y: @TypeOf(x)) @TypeOf(x) {
    // ignore overflow, marker and tags may not be set yet
    return x -% y; // NOTE: `-%` is wrapping sub in  Zig
}

fn fill(st: *State) ! Fill {
    if (st.eof) return Fill.Eof;

    // Error: lexeme too long. In real life could reallocate a larger buffer.
    if (st.tok < 1) return Fill.LongLexeme;

    // Shift buffer contents (discard everything up to the current token).
    std.mem.copy(u8, st.buf[0..], st.buf[st.tok..st.lim]);
    st.lim -= st.tok;
    st.cur -= st.tok;
    st.mar = shift(st.mar, st.tok);
    // Tag variables need to be shifted like other input positions. The check
    // for NONE is only needed if some tags are nested inside of alternative or
    // repetition, so that they can have NONE value.
    /*!stags:re2c format = "if (st.@@ != NONE) st.@@ = shift(st.@@, st.tok);\n"; */
    st.tok = 0;

    // Fill free space at the end of buffer with new data from file.
    const n = try st.file.read(st.buf[st.lim..BUFSIZE - 1]);
    st.lim += n;
    st.eof = n == 0;
    st.buf[st.lim] = 0;

    return Fill.Ok;
}

fn parse(st: *State) !?std.ArrayList(SemVer) {
    var vers = std.ArrayList(SemVer).init(st.alloc);
    // User-defined local variables that store final tag values.
    // They are different from tag variables autogenerated with `stags:re2c`,
    // as they are set at the end of match and used only in semantic actions.
    var t1: usize = undefined;
    var t2: usize = undefined;
    var t3: usize = undefined;
    var t4: usize = undefined;
    parse: while(true) {
        st.tok = st.cur;
    /*!re2c
        re2c:eof = 0;
        re2c:define:YYCTYPE     = u8;
        re2c:define:YYPEEK      = "st.buf[st.cur]";
        re2c:define:YYSKIP      = "st.cur += 1;";
        re2c:define:YYBACKUP    = "st.mar = st.cur;";
        re2c:define:YYRESTORE   = "st.cur = st.mar;";
        re2c:define:YYSTAGP     = "@@{tag} = st.cur;";
        re2c:define:YYSTAGN     = "@@{tag} = NONE;";
        re2c:define:YYSHIFTSTAG = "@@{tag} -= @bitCast(usize, @as(isize, -@@{shift}));";
        re2c:define:YYLESSTHAN  = "st.cur >= st.lim";
        re2c:define:YYFILL      = "try fill(st) == Fill.Ok";
        re2c:tags = 1;
        re2c:tags:expression = "st.@@";

        num = [0-9]+;

        num @t1 "." @t2 num @t3 ("." @t4 num)? [\n] {
            const major = s2n(st.buf[st.tok..t1]);
            const minor = s2n(st.buf[t2..t3]);
            const patch = if (t4 != NONE) s2n(st.buf[t4..st.cur - 1]) else 0;
            try vers.append(SemVer { .major = major, .minor = minor, .patch = patch });
            continue :parse;
        }
        $ { return vers; }
        * { return null; }
    */
    }
}

pub fn main() ! void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}) {};
    defer {
        _ = gpa.detectLeaks();
        _ = gpa.deinit();
    }
    const fname = "input";
    const verstr = "1.22.333\n";
    var expected = std.ArrayList(SemVer).init(gpa.allocator());
    defer expected.deinit();
    {
        var i: usize = 0;
        while (i < BUFSIZE) : (i += 1) {
            try expected.append(SemVer { .major = 1, .minor = 22, .patch = 333 });
        }
    }

    var cwd = std.fs.cwd();

    // Prepare input file (make sure it exceeds buffer size).
    {
        var created = cwd.createFile(fname, .{}) catch |err| {
            std.debug.panic("cannot open file `{s}`: {}", .{fname, err});
        };
        defer created.close();
        var i: usize = 0;
        while (i < BUFSIZE) : (i += 1) {
            try created.writeAll(verstr);
        }
    }

    // Reopen input file for reading.
    var file = cwd.openFile(fname, .{}) catch |err| {
        std.debug.panic("cannot read file {s}: {}", .{fname, err});
    };
    defer file.close();


    // Initialize lexer state.
    const lim = BUFSIZE - 1;
    var st = State {
        .alloc = gpa.allocator(),
        .file = &file,
        .buf = ([1]u8{0} ** BUFSIZE), // sentinel is set to zero, which triggers YYFILL
        .lim = lim,
        .cur = lim,
        .mar = lim,
        .tok = lim,
        /*!stags:re2c format = ".@@ = NONE,\n"; */
        .eof = false,
    };

    // Run the lexer and check results.
    const actual = (try parse(&st)) orelse @panic("Null Results");
    defer actual.deinit();
    if (actual.items.len != expected.items.len) {
        std.debug.panic("Expected {} items, but got {}", .{expected.items.len, actual.items.len});
    }
    for (actual.items) |ver, i| {
        const expectedItem = expected.items[i];
        if (!std.meta.eql(expectedItem, ver)) {
            std.debug.panic("Expected {}, but got {} for idx={}", .{expectedItem, ver, i});
        }
    }

    // Cleanup: remove input file.
    try cwd.deleteFile(fname);
}
